
ATOMIC_BOY_XCODE_PROJECT_FILEPATH = File.absolute_path('../AtomicBoy/AtomicBoy.xcodeproj')
GITHUB_REPO = 'lyndsey-ferguson/medium-post-fragile-tests'.freeze
GITHUB_TOKEN = File.read(File.absolute_path('../.github-token')).strip

lane :sweep do |_options|
  result = multi_scan(
    project: ATOMIC_BOY_XCODE_PROJECT_FILEPATH,
    try_count: 3,
    fail_build: false,
    scheme: 'AtomicBoy',
    output_directory: 'test_results',
    output_types: 'junit',
    output_files: 'report.junit'
  )
  failed_tests = result[:failed_tests]
  unless failed_tests.size.zero?
    suppress_failed_tests(failed_tests)

    failed_test_details(failed_tests).each do |failed_test, details|
      create_issue_github(
        title: "Fix failing test #{failed_test}",
        body: "`#{failed_test}` is failing on #{details[:location]} due to:\r\n" \
              "```\r\n" \
              "#{details[:failure]}\r\n" \
              "```\r\n"
      )
    end
  end
end

def suppress_failed_tests(failed_tests)
  git_checkout_newbranch = [
      'git',
      'checkout',
      '-b',
      "suppress_tests_#{Time.now.getutc.to_s.gsub(/[^0-9a-zA-Z]/, '_')}"
    ]
    Actions.sh(git_checkout_newbranch.join(' '))
    suppress_tests(
      xcodeproj: ATOMIC_BOY_XCODE_PROJECT_FILEPATH,
      tests: failed_tests,
      scheme: 'AtomicBoy'
    )
    git_commit(
      path: "#{ATOMIC_BOY_XCODE_PROJECT_FILEPATH}/**/*.xcscheme",
      message: 'Silence failing tests'
    )
    push_to_git_remote
    create_pull_request(
      api_token: GITHUB_TOKEN,
      repo: GITHUB_REPO,
      title: 'Silencing failing tests',
      body: pull_request_body(failed_tests)
    )
end

def pull_request_body(failed_tests)
  pr_body = "Silencing the following failing tests:\r\n```\r\n"
  failed_tests.each { |failed_test| pr_body << "#{failed_test}\r\n" }
  pr_body << "```\r\n@lyndsey-ferguson please review and merge!"
end

def failed_test_details(failed_tests)
  details = {}
  report_files = Dir.glob('../test_results/**/report.junit')
  report_files.each do |junit_report_filepath|
    report_file = File.open(junit_report_filepath) { |f| REXML::Document.new(f) }
    failed_tests.each do |failed_test|
      _, classname, testcase = failed_test.split('/')
      target_testcase = REXML::XPath.first(report_file, "//testcase[@name='#{testcase}' and @classname='#{classname}']")
      next if target_testcase.nil?

      failure_element = target_testcase.elements['failure']
      details[failed_test] = {
        failure: failure_element.attributes['message'],
        location: failure_element.text.strip
      }
    end
  end
  details
end

def create_issue_github(options)
  payload = {
    'state' => 'open'
  }
  get_issues_result = github_api(
    api_token: GITHUB_TOKEN,
    http_method: 'GET',
    path: "repos/#{GITHUB_REPO}/issues",
    body: payload
  )
  issue_exists = get_issues_result[:json].any? do |found_issue_result|
    is_issue = found_issue_result['pull_request'].nil?
    is_issue && found_issue_result['title'] == options[:title]
  end
  
  if issue_exists
    add_issue_comment_result = github_api()
    return
  end

  payload = {
    'title' => options[:title],
    'body' => options[:body]
  }

  post_new_issue_result = github_api(
    api_token: GITHUB_TOKEN,
    http_method: 'POST',
    path: "repos/#{GITHUB_REPO}/issues",
    body: payload,
    error_handlers: {
      '*' => proc do |post_new_issue_result|
        UI.error("GitHub responded with #{post_new_issue_result[:status]}: #{post_new_issue_result[:body]}")
        return nil
      end
    }
  )
  json = post_new_issue_result[:json]
  number = json['number']
  html_url = json['html_url']
  UI.success("Successfully created issue request ##{number}. You can see it at '#{html_url}'")
end
